### Decision: Should you use `zkverify-evm-dapp-example`?

**Verdict: YES.**

As a Senior Engineer, you shouldn't reinvent the wheel for the boilerplate. This repository is the official "Hello World" for the ecosystem. It contains the exact scaffolding needed to interact with the zkVerify chain and the EVM settlement layer.

**Why?**
1.  **Correct Abstractions:** It already uses `zkverifyjs`, which handles the complex RPC calls and Merkle proof generation.
2.  **Groth16 Native:** The example uses Circom+Groth16. **Reclaim Protocol also uses Groth16.** This means the data structures (`pi_a`, `pi_b`, `pi_c`) are identical.
3.  **Isolation:** It allows you to test the *verification* flow (Phase 2) completely independent of the *fetch* flow (Phase 1).

---

# Phase 2 Implementation Plan: The Settlement Layer

**Objective:** Successfully submit a Zero-Knowledge Proof to the zkVerify Testnet and receive a confirmed **Attestation ID**.
**Goal for this Phase:** We are **not** connecting Reclaim yet. We are establishing the pipeline to verify *any* Groth16 proof. We will use the repo's "Factorization" proof as our "Test Dummy."

---

## 1. Environment & Infrastructure Setup

Before writing code, we need the "plumbing" for the blockchain layer.

1.  **Wallet Setup:**
    *   Install **Talisman** or **SubWallet** browser extension.
    *   Create a new account.
    *   **Crucial:** Export your **Seed Phrase** (Mnemonic). You will need this for the backend script.
2.  **Faucet (Testnet Funds):**
    *   Go to the [zkVerify Faucet](https://faucet.zkverify.io/) (or the Discord faucet).
    *   Request **$VFY** (Volta Testnet tokens).
3.  **Clone the Repo:**
    ```bash
    git clone https://github.com/zkVerify/zkverify-evm-dapp-example.git astra-phase-2
    cd astra-phase-2/app
    npm install
    ```

---

## 2. The "Smoke Test" (Verify the Default Circuit)

Before we write custom scripts, run the existing logic to ensure your network connection and credentials work.

**A. Generate the Default Proof**
The repo comes with a circuit that proves you know factors of a number (e.g., $6 \times 7 = 42$).
*   Navigate to the root folder.
*   Run `make` inside the `circuit/` folder (requires `circom` and `snarkjs`).
    *   *If you don't have `circom` installed, skip this.* The repo usually has pre-generated `verification_key.json` and `proof.json` in `circuit/setup/` or `app/`.

**B. Configure Environment**
Inside `app/`:
```bash
cp .env.secrets.template .env.secrets
# Edit .env.secrets
# ZKV_SEED_PHRASE="your twelve words here"
```

**C. Run the Verification Script**
The repo contains `src/register_vk.js`. Run it.
```bash
node src/register_vk.js
```
**Success Criteria:**
*   Output: `vk hash: 0x...`
*   Transaction finalized on the terminal.

---

## 3. The Implementation (Writing the Astra Verify Module)

Now we write the code that will eventually serve as your **AstraVerify Settlement Service**. We will create a generic script that can take *any* Groth16 proof and verify it.

**Create File:** `app/src/verify_generic.js`

### The Code
This script is designed to be reusable. In Phase 3, we will simply pass the Reclaim proof into this function.

```javascript
const { zkVerifySession, Library, CurveType } = require("zkverifyjs");
const fs = require("fs");
const path = require("path");
require("dotenv").config({ path: [".env", ".env.secrets"] });

async function main() {
  console.log("ðŸš€ Starting Phase 2: zkVerify Settlement Service");

  // ---------------------------------------------------
  // 1. LOAD ARTIFACTS (The Test Dummy)
  // ---------------------------------------------------
  // In Phase 3, these will come dynamically from the Frontend.
  // For Phase 2, we load the "Factorization" dummy proof from the repo.
  const BASE_PATH = "../circuit/setup"; 
  
  // The Verification Key (The Public "Lock")
  const vk = JSON.parse(fs.readFileSync(path.join(BASE_PATH, "verification_key.json")));
  
  // The Proof (The "Key" generated by the Prover)
  // Note: Standard snarkjs output
  const proof = JSON.parse(fs.readFileSync(path.join(BASE_PATH, "proof.json")));
  
  // The Public Signals (The Public Inputs, e.g., "42")
  const publicSignals = JSON.parse(fs.readFileSync(path.join(BASE_PATH, "public.json")));

  console.log(`> Artifacts loaded. Verifying proof for Public Signal: [${publicSignals}]`);

  // ---------------------------------------------------
  // 2. INITIALIZE SESSION
  // ---------------------------------------------------
  // We connect to zkVerify Testnet (Volta)
  const session = await zkVerifySession.start()
    .Testnet()
    .withAccount(process.env.ZKV_SEED_PHRASE);

  console.log("> Session started. Submitting to zkVerify Chain...");

  // ---------------------------------------------------
  // 3. EXECUTE VERIFICATION
  // ---------------------------------------------------
  try {
    const { transactionResult } = await session.verify()
      .groth16(Library.snarkjs, CurveType.bn254)
      .waitForPublishedAttestation() // Critical: Waits for block finality
      .execute({
        proofData: {
          vk: vk,
          proof: proof,
          publicSignals: publicSignals
        }
      });

    console.log("> Transaction sent. Waiting for Finality (approx 10-20s)...");

    // ---------------------------------------------------
    // 4. HANDLE RESULTS
    // ---------------------------------------------------
    const { transactionHash, attestationId, leafDigest } = await transactionResult;

    console.log("\nâœ… VERIFICATION SUCCESSFUL");
    console.log("-------------------------------------------");
    console.log(`ðŸ”¹ Transaction Hash: ${transactionHash}`);
    console.log(`ðŸ”¹ Attestation ID:   ${attestationId}`);
    console.log(`ðŸ”¹ Leaf Digest:      ${leafDigest}`);
    console.log(`ðŸ”— Explorer:         https://zkverify-testnet.subscan.io/extrinsic/${transactionHash}`);
    console.log("-------------------------------------------");

  } catch (error) {
    console.error("âŒ Verification Failed:", error);
    if (error.data) console.error("Error Details:", error.data);
  }
}

main()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
```

---

## 4. Execution & Verification

1.  **Run the script:**
    ```bash
    node src/verify_generic.js
    ```

2.  **Verify the Output:**
    *   **Console:** You should see `âœ… VERIFICATION SUCCESSFUL`.
    *   **Explorer:** Click the link generated in the console.
    *   **Check:** Look for the event `poe.AttestationPosted` or similar in the Extrinsic details.

## 5. Senior Engineer Analysis: "The Gap" (Preparation for Phase 3)

Since you are verifying this individually, you need to understand the **Data Mismatch** you will face in Phase 3.

*   **Current State (Phase 2):** We are reading `proof.json` from a file. This is a standard `snarkjs` output:
    ```json
    { "pi_a": [...], "pi_b": [...], "pi_c": [...] }
    ```
*   **Future State (Phase 3):** Reclaim SDK returns a `Proof` object that looks different. It often wraps the Groth16 proof inside a string field or a nested object called `claim`.

**Action Item for Phase 3:**
When we combine them, we will need a **Mapper Function** to transform the Reclaim Output -> Standard SnarkJS format required by `zkverifyjs`.

**Phase 2 is complete when:**
1.  You have the `zkverify-evm-dapp-example` repo cloned.
2.  Your `.env.secrets` has a funded wallet.
3.  You can run `node src/verify_generic.js` and get a green success message with a Transaction Hash.